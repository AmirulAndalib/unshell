#!/bin/env bash

ulimit -s unlimited >/dev/null 2>&1

show_usage_unshell() {
	printf "%s - Deobfuscate any shell scripts with multiple methods
  Usage: %s [OPTION].. [FILE]...

  Options:
    -h, --help
      print this message
    -f, --file [FILE]...
      Scripts you wanted to deobfuscate, multi input is supported
    -v, --verbose
      Be verbose
    -d, --execve-delay [SECOND]
      Set custom execve delay time in seconds for SHC and SSC encryption
    -U, --update
      Update the script

  Example usages:
    %s -f install.sh menu.sh
    %s -v -f /system/bin/gaming_script
    %s -d 6.018 -f ./VTK
    \n" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}"
	exit 0
}

update_script() {
	temp="$HOME/unshell.temp"
	which_is_unshell=$(which unshell)

	if [ -z "$which_is_unshell" ]; then
		echo "error: unshell command not found"
		exit 1
	fi

	# Download the latest version
	if ! curl -Lo "$temp" https://github.com/Rem01Gaming/unshell/raw/main/unshell; then
		rm -f "$temp"
		echo "error: failed to download update script"
		exit 1
	fi

	# Ensure the current binary is removed only after successful download
	if rm -f "$which_is_unshell" && mv "$temp" "$which_is_unshell"; then
		chmod +x "$which_is_unshell"
		echo "Updated successfully"
		exit 0
	else
		echo "error: failed to update"
		exit 1
	fi
}

decrypt_ssc() {
	counter=$((counter + 1))
	echo "Layer $counter: ssc"
	spath=$(echo $PATH | cut -d: -f1)
	cp ./$filename.temp1.sh $spath/$filename.temp1.sh
	chmod +x $spath/$filename.temp1.sh

	if [ -z $EXECVE_DELAY ]; then
		for sec in {10..28}; do
			$filename.temp1.sh &
			child=$!
			sleep 0.0"$sec"
			kill -STOP $child
			cat /proc/$child/fd/3 >"./$filename.temp2.sh"
			kill -TERM $child

			if [ -s ./$filename.temp2.sh ]; then
				break
			fi
		done
	else
		$filename.temp1.sh &
		child=$!
		sleep $EXECVE_DELAY
		kill -STOP $child
		cat /proc/$child/fd/3 >"./$filename.temp2.sh"
		kill -TERM $child
	fi

	rm -f $spath/$filename.temp1.sh
	if [ -s ./$filename.temp2.sh ]; then
		if ! grep -q '#!/' "./$filename.temp2.sh"; then
			echo "notice: Output script maybe truncated"
		fi

		mv ./$filename.temp2.sh ./$filename.temp1.sh
	else
		rm ./$filename.temp2.sh ./$filename.temp1.sh
	fi
}

decrypt_shc() {
	counter=$((counter + 1))
	echo "Layer $counter: shc"
	spath=$(echo $PATH | cut -d: -f1)
	cp ./$filename.temp1.sh $spath/$filename.temp1.sh
	chmod +x $spath/$filename.temp1.sh

	if [ -z $EXECVE_DELAY ]; then
		for sec in {1..7}; do
			$filename.temp1.sh &
			child=$!
			sleep 0.0"$sec"
			kill -STOP $child
			cat /proc/$child/cmdline | sed 's/.*\(#!\)/\1/' >"./$filename.temp2.sh"
			kill -TERM $child

			if grep -q '#!/' "./$filename.temp2.sh"; then
				break
			fi
		done
	else
		$filename.temp1.sh &
		child=$!
		sleep $EXECVE_DELAY
		kill -STOP $child
		cat /proc/$child/cmdline | sed 's/.*\(#!\)/\1/' >"./$filename.temp2.sh"
		kill -TERM $child
	fi

	rm -f $spath/$filename.temp1.sh
	if grep -q '#!/' "./$filename.temp2.sh"; then
		mv ./$filename.temp2.sh ./$filename.temp1.sh
	else
		rm ./$filename.temp2.sh ./$filename.temp1.sh
	fi
}

decrypt_bashrock() {
	counter=$((counter + 1))
	echo "Layer $counter: bashrock"
	sed 's/eval "$x";/echo "$x";/g' ./$filename.temp1.sh >./$filename.temp2.sh
	bash ./$filename.temp2.sh >./$filename.temp1.sh
	rm ./$filename.temp2.sh
}

decrypt_bashprotector() {
	counter=$((counter + 1))
	echo "Layer $counter: bashprotector"
	sed 's/\beval\b/echo/g' ./$filename.temp1.sh >./$filename.temp2.sh
	bash ./$filename.temp2.sh | bash >./$filename.temp1.sh
	rm ./$filename.temp2.sh
}

decrypt_bashobsf() {
	counter=$((counter + 1))
	echo "Layer $counter: bash-obfuscate"
	sed 's/eval "\$/echo "\$/g; s/\[ "$(id -u)" -ne 2000 \]/! true/' ./$filename.temp1.sh >./$filename.temp2.sh
	bash ./$filename.temp2.sh >./$filename.temp1.sh
	rm ./$filename.temp2.sh
}

decrypt_base64() {
	counter=$((counter + 1))
	echo "Layer $counter: base64"
	sed 's/base64 -d | [a-z\/]*sh/base64 -d/; s/\[ "$(id -u)" -ne 2000 \]/! true/' ./$filename.temp1.sh >./$filename.temp2.sh
	bash ./$filename.temp2.sh >./$filename.temp1.sh
	rm ./$filename.temp2.sh
}

decrypt_bzip2() {
	counter=$((counter + 1))
	echo "Layer $counter: bzip2"
	skip=$(($(sed -n 2p ./$filename.temp1.sh | awk -F'=' '{print $2}') - 1))
	sed 1,${skip}d ./$filename.temp1.sh >./$filename.temp2.sh
	bzip2 -cd ./$filename.temp2.sh >./$filename.temp1.sh
	rm ./$filename.temp2.sh
}

decrypt_axeron() {
	counter=$((counter + 1))
	echo "Layer $counter: Axeron online module"

	cat <<"EOF" >./temp_functions.sh
rozaq() {
	if [ "$1" = "-d" ] && [ -n "$2" ]; then
		[[ "${2:0:3}" = "r17" ]] && echo "${2:3}" | tr R-ZA-Qr-za-q A-Za-z | base64 -d || echo "$2"
	else
		echo "r17$(echo -n "$1" | base64 | tr A-Za-z R-ZA-Qr-za-q)"
	fi
}

storm() {
	obsf_link=$(echo $2)
	rozaq -d $obsf_link
}
EOF

	REP_FUNCTION="./temp_functions.sh"
	sed "s|source \$FUNCTION|source $REP_FUNCTION|; s/\[ \"\$(id -u)\" -ne 2000 \]/! true/" ./$filename.temp1.sh >./$filename.temp2.sh
	obsf_link=$(bash ./$filename.temp2.sh)
	echo "Obfuscated link: $obsf_link"
	echo "Downloading script..."
	rm $REP_FUNCTION
	curl -Lo ./$filename.temp1.sh $obsf_link
	# Don't use '||' here, just don't
	[ $? -gt 0 ] && rm ./$filename.temp1.sh && echo "error: unable to download axeron script." && return 1
}

init_dec() {
	while true; do
		if [ ! -f ./$filename.temp1.sh ]; then
			break
		elif grep -q '$RzE' ./$filename.temp1.sh; then
			decrypt_bashrock
			PASSED_LOOP=1
		elif grep -q 'Tx=Eds' ./$filename.temp1.sh; then
			decrypt_bashprotector
			PASSED_LOOP=1
		elif grep -q 'z=.*;.*z=.*;' ./$filename.temp1.sh && grep -q 'eval' ./$filename.temp1.sh; then
			decrypt_bashobsf
			PASSED_LOOP=1
		elif grep -q 'storm\s-x' ./$filename.temp1.sh; then
			decrypt_axeron
			PASSED_LOOP=1
		elif grep -q '/bin/bzip2\s-cd' ./$filename.temp1.sh && grep -q 'skip=23' ./$filename.temp1.sh; then
			decrypt_bzip2
			PASSED_LOOP=1
		elif grep -q 'base64 -d | [a-z\/]*sh$' ./$filename.temp1.sh; then
			decrypt_base64
			PASSED_LOOP=1
		elif strings ./$filename.temp1.sh | grep -q 'SSC_ARGV0'; then
			decrypt_ssc
			PASSED_LOOP=1
		elif strings ./$filename.temp1.sh | grep -q 'E:\sneither\sargv\[0\]\snor\s\$_\sworks\.'; then
			decrypt_shc
			PASSED_LOOP=1
		else
			[ $PASSED_LOOP -eq 0 ] && rm ./$filename.temp1.sh && echo "error: uknown patterns, deobfuscation is not supported."
			break
		fi
	done

	if [ ! -s ./$filename.temp1.sh ]; then
		echo "Failed to deobfuscate $1"
		remove_temp
		return 1
	fi

	mv ./$filename.temp1.sh ./$filename.dec.sh
	echo "./$filename.dec.sh unshelled"
	remove_temp
}

remove_temp() {
	rm -f ./$filename.temp*.sh
	counter=0
}

if ! hash strings curl; then
	echo "error: environment has missing dependencies"
	exit 1
fi

while [[ $# -gt 0 ]]; do
	case $1 in
	-h | --help)
		show_usage_unshell
		exit 0
		;;
	-v | --verbose)
		set -x
		shift
		;;
	-d | --execve-delay)
		shift
		if [[ $1 =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
			EXECVE_DELAY=$1
		else
			echo -e "error: execve delay MUST be a positive integer or decimal number!\nFor help, type: 'unshell --help'."
			exit 1
		fi
		shift
		;;
	-U | --update)
		update_script
		shift
		;;
	-f | --file)
		shift
		break
		;;
	*)
		echo -e "error: bad option\nFor help, type: 'unshell --help'."
		exit 1
		;;
	esac
done

if [ -z $1 ]; then
	echo -e "error: no input file\nFor help, type: 'unshell --help'."
fi

for file in "$@"; do
	if [ ! -f "$file" ]; then
		echo "error: file $file does not exist!"
	else
		PASSED_LOOP=0
		filename=$(basename "$file")
		cp "$file" "./$filename.temp1.sh"
		echo "Deobfuscating $file â†’ ./$filename.dec.sh"
		init_dec "$file"
	fi
done
